require "rubygems"
require "trollop"
require "erb"
require "pathname"
require File.join(File.dirname(__FILE__), "options.rb")
require File.join(File.dirname(__FILE__), "tar_wrapper.rb")

module Groundwork
  class Recipe
    def initialize &block
      if block_given?
        instance_eval &block
      end
    end

    def tar= data
      @tar = TarWrapper.new(data)
    end

    # Creates a directory. If a block is passed,
    # the block will be run inside that directory
    def directory *name, &block
      FileUtils.mkdir_p File.join(name)
      if block_given?
        FileUtils.cd File.join(name), &block
      end
    end

    # If opts is a string, it's the contents of the file, verbatim
    # If opts is a hash, it must contain either:
    # * :from, copies the text of the given filename verbatim
    # * :from_erb, uses the text of the filename as an erb template
    # * :erb, uses the given string as an erb template
    def file name, opts = nil
      name = File.join(name)
      File.open(File.join(name),"w") do |file|
        if opts.is_a? String
          file.print opts
        elsif opts.is_a? Hash
          file.print( if opts[:from]
                        read_file opts[:from]
                      elsif opts[:from_erb]
                        ERB.new(read_file(opts[:from_erb])).result(binding)
                      elsif opts[:erb]
                        ERB.new(opts[:erb]).result(binding)
                      end )
        elsif opts.nil?
          # write nothing
        else
          raise ArgumentError.new
        end
      end
    end

    # When you compile a recipe, it runs it to determine which files to bake in.
    # If you have a file that might not be generated by running your script with
    # no options, you can call possible on it to ensure it gets baked into
    # the script. This function only has an effect during compilation, it does
    # nothing when the script is actually run.
    def possible name ; end

    # Takes a block and lists the files that that block will require as templates.
    # See Groundwork::Recipe#possible
    def self.required_files &block
      dummy = Object.new
      files = []

      class << dummy
        attr_reader :files

        def directory *args
          yield if block_given?
        end

        def file name, opts=nil
          @files << opts[:from] if opts[:from]
          @files << opts[:from_erb] if opts[:from_erb]
        end

        def possible name
          @files << name
        end

        def method_missing *args ; end
      end

      dummy.instance_variable_set "@files", []
      dummy.instance_eval &block

      dummy.files
    end

    def self.compile_file filename
      compile File.read(filename), File.dirname(filename)
    end

    # Takes a script file, finds the files it requires (paths relative to the script file),
    # reads/tars them and returns a string containing the script and the TAR blob, ready
    # to write to a file
    def self.compile script, in_directory
      out = StringIO.new
      data = nil

      FileUtils.cd(in_directory) do
        files = required_files do
          eval script
        end

        data = TarWrapper.compress files
      end

      out.puts script
      out.puts ""
      out.puts "__END__"
      out.puts data

      out.string
    end

    # Takes a filename and runs the script contained in it. The file should be
    # the results of Groundwork::Recipe#compile
    def self.run script_file
      (script, data) = File.read(script_file).split("\n__END__\n")

      Groundwork::Recipe.new do
        self.tar = data
        eval script
      end
    end

    # Generate a tree of file and directory calls that would create the given
    # directory
    def self.generate dir = FileUtils.pwd, options = {}
      base = Pathname.new dir

      handle_dir = lambda do |d, output, indent|
        FileUtils.cd d do
          Dir["*"].each do |file|
            rel = Pathname.new(File.join(FileUtils.pwd,file))
            relpath = rel.relative_path_from(base).to_s

            next if options[:ignore] && options[:ignore].any?{|p| File.fnmatch(p,relpath) }

            if File.directory? file
              if Dir[File.join(file,"*")].empty?
                output.puts((" "*indent)+"directory \"#{file}\"")
              else
                output.puts("")
                output.puts((" "*indent)+"directory \"#{file}\" do")
                handle_dir[file, output, indent+2]
                output.puts((" "*indent)+"end")
                output.puts("")
              end
            else
              output.puts((" "*indent)+"file \"#{file}\", :from => \"#{relpath}\"")
            end
          end
        end
      end

      str = StringIO.new
      handle_dir[dir, str, 0]
      str.string.gsub(/\n\n+/,"\n\n") # Collapse adjacent blank lines
    end

    private

    def read_file name
      if @tar
        @tar[name]
      else
        File.read(name)
      end
    end
  end

  # Return a hash of all known recipes, the included ones and the ones in .groundwork
  def self.known_recipes
    recipes = {}
    Dir[File.join(File.dirname(__FILE__),"..","recipes","*.recipe")].each do |recipe|
      recipes[File.basename(recipe,".recipe")] = recipe
    end

    dot_groundwork = File.expand_path("~/.groundwork")

    if File.directory?(dot_groundwork)
      Dir[File.join(dot_groundwork,"*.recipe")].each do |recipe|
        recipes[File.basename(recipe,".recipe")] = recipe
      end
    end

    recipes
  end
end
