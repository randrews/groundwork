require "erb"
require "tar_wrapper.rb"

class Kickstart
  def initialize &block
    if block_given?
      instance_eval &block
    end
  end

  def data_block= stream
    @tar = TarWrapper.new(stream.read)
  end

  def directory *name, &block
    FileUtils.mkdir_p File.join(name)
    if block_given?
      FileUtils.cd File.join(name), &block
    end
  end

  # If opts is a string, it's the contents of the file, verbatim
  # If opts is a hash, it must contain either:
  # * :from, copies the text of the given filename verbatim
  # * :from_erb, uses the text of the filename as an erb template
  # * :erb, uses the given string as an erb template
  def file name, opts = nil
    name = File.join(name)
    File.open(File.join(name),"w") do |file|
      if opts.is_a? String
        file.print opts
      elsif opts.is_a? Hash
        file.print( if opts[:from]
                      read_file opts[:from]
                    elsif opts[:from_erb]
                      ERB.new(read_file(opts[:from_erb])).result(binding)
                    elsif opts[:erb]
                      ERB.new(opts[:erb]).result(binding)
                    end )
      elsif opts.nil?
        # write nothing
      else
        raise ArgumentError.new
      end
    end
  end

  # When you compile a recipe, it runs it to determine which files to bake in.
  # If you have a file that might not be generated by running your script with
  # no options, you can call possible_file on it to ensure it gets baked into
  # the script. This function only has an effect during compilation, it does
  # nothing when the script is actually run.
  def possible name ; end

  def self.required_files &block
    dummy = Object.new
    files = []

    class << dummy
      attr_reader :files

      def directory *args
        yield if block_given?
      end

      def file name, opts=nil
        @files << opts[:from] if opts[:from]
        @files << opts[:from_erb] if opts[:from_erb]
      end

      def possible name
        @files << name
      end

      def method_missing *args ; end
    end

    dummy.instance_variable_set "@files", []
    dummy.instance_eval &block

    dummy.files
  end

  # Takes a script file, finds the files it requires (paths relative to the script file),
  # reads/tars them and returns a string containing the script and the TAR blob, ready
  # to write to a file
  def self.compile script_file
    script = File.read(script_file)
    out = StringIO.new
    data = nil

    FileUtils.cd(File.dirname(script_file)) do
      files = required_files do
        eval script
      end

      data = TarWrapper.compress files
    end

    out.puts "self.data_block = DATA # generated"
    out.puts script
    out.puts "__END__"
    out.puts data

    out.string
  end

  private

  def read_file name
    if @tar
      @tar[name]
    else
      File.read[name]
    end
  end
end
